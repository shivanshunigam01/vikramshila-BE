"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.reviveDates = exports.manageExpiredToken = void 0;
exports.buildErrorContext = buildErrorContext;
exports.invalidateAndRegenerateJwt = invalidateAndRegenerateJwt;
const request_plugin_1 = require("../plugins/core/request-plugin");
const api_errors_1 = require("../api/api-errors");
const manageExpiredToken = async (apiCallParameters, errorContext, requestPlugins) => {
    // Use the circuitBreaker variable to try to regenerate a valid JWT only 3 times
    if (!apiCallParameters.circuitBreaker) {
        apiCallParameters.circuitBreaker = 1;
    }
    else {
        apiCallParameters.circuitBreaker++;
        // Check the circuitBreaker value: if greater than 3, then we stop and throw
        if (apiCallParameters.circuitBreaker >= 3) {
            throw new api_errors_1.GenericError('Tried to generate a new JWT with no success', errorContext);
        }
    }
    return await invalidateAndRegenerateJwt(requestPlugins, apiCallParameters.requestOptions, errorContext);
};
exports.manageExpiredToken = manageExpiredToken;
function buildErrorContext(apiCallParameters) {
    return {
        apiName: apiCallParameters.apiName,
        operationId: apiCallParameters.operationId,
        url: apiCallParameters.url,
    };
}
async function invalidateAndRegenerateJwt(requestPlugins, options, errorContext) {
    const oauth2Plugin = requestPlugins?.find((plugin) => plugin.getName() === request_plugin_1.RequestPluginEnum.OAUTH2_TOKEN_REQUEST);
    if (oauth2Plugin) {
        oauth2Plugin.invalidateToken();
        return oauth2Plugin.load().transform(options);
    }
    else {
        const errorMessage = 'Trying to invalidate an expired JWT while the Oauth2Token plugin is not registered to the API client';
        throw new api_errors_1.GenericError(errorMessage, errorContext);
    }
}
/**
 * Go through all an object's properties and transform to date the values that match the right format
 * @param {any} input - the response object after all the response plugins have been run
 * @return {any} - the response where the values matching a date are revived as Date objects
 */
const reviveDates = (input) => {
    if (Array.isArray(input)) {
        // Process array elements recursively
        return input.map((item) => (0, exports.reviveDates)(item));
    }
    else if (typeof input === 'object' && input !== null) {
        // Process object properties recursively
        const newObj = {};
        for (const key in input) {
            if (Object.prototype.hasOwnProperty.call(input, key)) {
                newObj[key] = (0, exports.reviveDates)(input[key]);
            }
        }
        return newObj;
    }
    else if (isDateString(input)) {
        // Convert string date to Date object
        return new Date(addTimezoneIfMissing(input));
    }
    else {
        // Return other types as-is
        return input;
    }
};
exports.reviveDates = reviveDates;
const isDateString = (value) => {
    if (typeof value === 'string' && value.length >= 10) {
        const date = new Date(value);
        return !isNaN(date.getTime()) && date.toISOString().slice(0, 10) === value.slice(0, 10);
    }
    return false;
};
const addTimezoneIfMissing = (timestampValue) => {
    // Check the formats +XX:XX, +XX, +XXXX and Z
    const timeZoneRegex = /([+-]\d{2}(:\d{2})|[+-]\d{4}|Z)$/;
    if (!timeZoneRegex.test(timestampValue)) {
        const hourMinutesTimezoneRegex = /([+-]\d{2})$/;
        // A timestamp with no minutes in the timezone cannot be converted into a Date => assume it's :00
        if (hourMinutesTimezoneRegex.test(timestampValue)) {
            timestampValue = timestampValue + ':00';
        }
        else {
            timestampValue = timestampValue + 'Z';
        }
    }
    return timestampValue;
};
//# sourceMappingURL=api-client-helpers.js.map