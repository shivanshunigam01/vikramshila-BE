"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApiFetchClient = void 0;
const version_1 = require("../plugins/version");
const exception_1 = require("../plugins/exception");
const api_client_1 = require("../api/api-client");
const api_errors_1 = require("../api/api-errors");
const node_fetch_1 = __importDefault(require("node-fetch"));
const api_client_helpers_1 = require("./api-client-helpers");
const api_client_pagination_helper_1 = require("./api-client-pagination-helper");
/** Client to process the call to the API using Fetch API */
class ApiFetchClient extends api_client_1.ApiClient {
    /**
     * Initialize your API Client instance with the provided configuration options.
     * Default request plugins: VersionRequest
     * Default response plugins: ExceptionResponse
     *
     * @param {ApiClientOptions} options - Configuration options for the API Client.
     */
    constructor(options) {
        super({
            ...options,
            requestPlugins: [new version_1.VersionRequest(), ...(options.requestPlugins || [])],
            responsePlugins: [
                new exception_1.ExceptionResponse(),
                ...(options.responsePlugins || []),
            ],
        });
    }
    /** @inheritdoc */
    async processCall(apiCallParameters) {
        const responseContext = await this.executeRequest(apiCallParameters);
        return this.processResponse(responseContext);
    }
    /** @inheritdoc */
    async processCallWithPagination(apiCallParameters) {
        const responseContext = await this.executeRequest(apiCallParameters);
        const transformedResponse = await this.processResponse(responseContext);
        return this.buildPageResult(transformedResponse, apiCallParameters);
    }
    /** @inheritdoc */
    async processFileCall(apiCallParameters) {
        const responseContext = await this.executeRequest(apiCallParameters, true);
        return this.processFileResponse(responseContext);
    }
    async executeRequest(apiCallParameters, isFileDownload = false) {
        const errorContext = (0, api_client_helpers_1.buildErrorContext)(apiCallParameters);
        try {
            const response = await this.sinchFetch(apiCallParameters, errorContext);
            const body = isFileDownload ? undefined : await response.text();
            return {
                response,
                body,
                apiCallParameters,
                errorContext,
            };
        }
        catch (error) {
            throw this.buildFetchError(error, errorContext);
        }
    }
    async processResponse(context) {
        const pluginContext = await this.parseAndValidateResponse(context);
        const transformedResponse = await this.applyResponsePlugins(pluginContext);
        if (pluginContext.exception) {
            throw pluginContext.exception;
        }
        return (0, api_client_helpers_1.reviveDates)(transformedResponse);
    }
    async parseAndValidateResponse(context) {
        let result;
        let exception;
        try {
            result = context.body ? JSON.parse(context.body) : undefined;
        }
        catch (error) {
            exception = new api_errors_1.ResponseJSONParseError(error.message || 'Failed to parse response body', (context.response?.status || 0), context.errorContext, context.body);
        }
        return { result, exception, responseContext: context };
    }
    async processFileResponse(context) {
        if (!context.response || !context.response.ok) {
            throw this.buildFetchError(new Error('No response received'), context.errorContext);
        }
        const buffer = await context.response.buffer();
        const fileName = this.extractFileName(context.response.headers);
        if (!buffer || !fileName) {
            throw new Error('An error occurred while downloading the file');
        }
        return { fileName, buffer };
    }
    /**
     * Handle fetch request with token refresh mechanism
     * @param {ApiCallParameters} apiCallParameters
     * @param {ErrorContext} errorContext
     */
    async sinchFetch(apiCallParameters, errorContext) {
        let response = await (0, node_fetch_1.default)(apiCallParameters.url, apiCallParameters.requestOptions);
        if (this.isTokenExpired(response)) {
            const requestOptions = await (0, api_client_helpers_1.manageExpiredToken)(apiCallParameters, errorContext, this.apiClientOptions.requestPlugins);
            response = await (0, node_fetch_1.default)(apiCallParameters.url, requestOptions);
        }
        return response;
    }
    isTokenExpired(response) {
        return response.status === 401
            && response.headers.get('www-authenticate')?.includes('expired') === true;
    }
    async applyResponsePlugins(context) {
        const plugins = this.loadResponsePlugins(this.apiClientOptions.responsePlugins, context.responseContext);
        return plugins.reduce(async (promise, plugin) => {
            const current = await promise;
            return plugin.transform(current);
        }, Promise.resolve(context.result || {}));
    }
    loadResponsePlugins(plugins, context) {
        return (plugins || []).map(plugin => plugin.load({
            response: context.response,
            exception: undefined,
            apiName: context.apiCallParameters.apiName,
            operationId: context.apiCallParameters.operationId,
            url: context.apiCallParameters.url,
            requestOptions: context.apiCallParameters.requestOptions,
        }));
    }
    buildPageResult(transformedResponse, apiCallParameters) {
        const responseData = transformedResponse[apiCallParameters.dataKey];
        const paginationContext = (0, api_client_pagination_helper_1.buildPaginationContext)(apiCallParameters);
        const nextPage = JSON.stringify((0, api_client_pagination_helper_1.calculateNextPage)(transformedResponse, paginationContext));
        return {
            data: responseData || [],
            hasNextPage: (0, api_client_pagination_helper_1.hasMore)(transformedResponse, paginationContext),
            nextPageValue: nextPage,
            nextPage: () => (0, api_client_pagination_helper_1.createNextPageMethod)(this, paginationContext, apiCallParameters.requestOptions, nextPage),
        };
    }
    buildFetchError(error, errorContext) {
        if (error instanceof api_errors_1.GenericError) {
            return new api_errors_1.GenericError(error.message, errorContext);
        }
        else {
            return new api_errors_1.EmptyResponseError(error.message || 'Fail to fetch', errorContext);
        }
    }
    extractFileName(headers) {
        const contentDisposition = headers.get('content-disposition');
        let fileName = 'default-name.pdf';
        if (contentDisposition) {
            const match = contentDisposition.match(/filename="([^"]+)"/);
            if (match && match[1]) {
                fileName = match[1];
            }
        }
        return fileName;
    }
}
exports.ApiFetchClient = ApiFetchClient;
//# sourceMappingURL=api-fetch-client.js.map